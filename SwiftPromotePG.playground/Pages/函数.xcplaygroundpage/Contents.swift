//: [Previous](@previous)

import Foundation

typealias 因特性 = Int
typealias 大波型 = Double



var 函数简化 = "函数简化"
print("\(函数简化)")

func doubler(i: Int) -> Int {
    return i * 2
}
[1, 2, 3, 4].map(doubler) // [2, 4, 6, 8]”

//1.如果你将闭包作为参数传递，并且你不再用这个闭包做其他事情的话，就没有必要现将它存储到一个局部变量中。可以想象一下比如 5*i 这样的数值表达式，你可以把它直接传递给一个接受 Int 的函数，而不必先将它计算并存储到变量里。
[1, 2, 3].map( { (i: Int) -> Int in return i * 2 } )

//2.如果编译器可以从上下文中推断出类型的话，你就不需要指明它了。在我们的例子中，从数组元素的类型可以推断出传递给 map 的函数接受 Int 作为参数，从闭包的乘法结果的类型可以推断出闭包返回的也是 Int。
[1, 2, 3].map( { i in return i * 2 } )

//3.如果闭包表达式的主体部分只包括一个单一的表达式的话，它将自动返回这个表达式的结果，你可以不写 return。

[1, 2, 3].map( { i in i * 2 } )

//4.Swift 会自动为函数的参数提供简写形式，$0 代表第一个参数，$1 代表第二个参数，以此类推。
[1, 2, 3].map( { $0 * 2 } )

//5.如果函数的最后一个参数是闭包表达式的话，你可以将这个闭包表达式移到函数调用的圆括号的外部。这样的尾随闭包语法在多行的闭包表达式中表现非常好，因为它看起来更接近于装配了一个普通的函数定义，或者是像 if (expr) { } 这样的执行块的表达形式。
[1, 2, 3].map() { $0 * 2 }
//6.最后，如果一个函数除了闭包表达式外没有别的参数，那么方法名后面的调用时的圆括号也可以一并省略。”

[1, 2, 3].map { $0 * 2 }


//函数灵活性

//swift 可以对任意可以使用比较函数（返回NSComparisonResult的函数）进行排序











